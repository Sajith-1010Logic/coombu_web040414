package com.coombu.photobook.model;

import java.io.IOException;
import java.io.Serializable;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.faces.context.FacesContext;
import javax.faces.event.PhaseId;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.Table;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
// Generated Nov 3, 2013 6:30:53 PM by Hibernate Tools 4.0.0
import javax.persistence.Transient;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;

import org.hibernate.annotations.LazyCollection;
import org.hibernate.annotations.LazyCollectionOption;
import org.primefaces.model.DefaultStreamedContent;
import org.primefaces.model.StreamedContent;
import org.primefaces.model.UploadedFile;
import javax.persistence.OrderBy;
/**
 * Image generated by hbm2java
 */
@XmlRootElement
@Entity
@Table(name = "image")
public class Image extends AuditTrail implements Serializable {

	private static final long serialVersionUID = 1L;
	
	@Id
	@GeneratedValue(strategy=GenerationType.AUTO)
	@Column(name = "IMAGE_ID", unique = true, nullable = false)
	private long imageId;
	
	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "EVENT_ID", nullable = false)
	private Event event;

	@ManyToOne(fetch = FetchType.EAGER)
	@JoinColumn(name = "EVENT_SECURITY_USER_ID", nullable = false)
	private EventSecurityUser eventSecurityUser;

	@Column(name = "FILE_ID", nullable = false)
	private String fileId;
	
	@Column(name = "FILE_NAME", nullable = false)
	private String fileName;

	@Column(name = "FILE_PATH", nullable = false, length = 260)
	private String filePath;

	@Temporal(TemporalType.TIMESTAMP)
	@Column(name = "UPLOAD_DATE_TIME", nullable = false, length = 19)
	private Date uploadDateTime;
	
	@Column(name = "FILE_SIZE", nullable = false)
	private long fileSize;

	@Column(name = "IMAGE_WIDTH", nullable = false)
	private int imageWidth;

	@Column(name = "IMAGE_HEIGHT", nullable = false)
	private int imageHeight;
	
	@Column(name = "FILE_TYPE_ID", nullable = false)
	private Short fileTypeId;

	@Column(name = "EVENT_DESCRIPTION", nullable = false)
	private String eventDescription;

	@Column(name = "IMAGE_SOURCE_ID")
	private Short imageSourceId;

	@Column(name = "IMAGE_STATUS_TYPE_ID", nullable = false)
	private short imageStatusTypeId;
	
	
	@Column(name = "ORIGINAL_FILE_NAME")
	private String originalFileName;
	

	@OneToMany(fetch = FetchType.LAZY, mappedBy = "image")
	@LazyCollection(LazyCollectionOption.EXTRA)
	private List<ImageTag> imageTags = new ArrayList<>(0);

	@OneToMany(fetch = FetchType.LAZY, mappedBy = "image")
	@LazyCollection(LazyCollectionOption.EXTRA)
	private Set<ImageVote> imageVotes = new HashSet<>(0);


	/**
	 * Comments have to be lazy loaded for pagination to work.
	 * Please do NOT change. If you want comments to be eagerly loaded
	 * set the FetchMode in the query.
	 */
	
	@OneToMany(fetch = FetchType.LAZY, mappedBy = "image")
	@LazyCollection(LazyCollectionOption.EXTRA)
	@OrderBy("createTimestamp DESC" )
	private Set<Comment> comments = new HashSet<>(0);

	@OneToMany(fetch = FetchType.LAZY, mappedBy = "image")
	@LazyCollection(LazyCollectionOption.EXTRA)
	private Set<ImageViewCount> imageViewCount = new HashSet<>(0);
	/**
	 * uploadedFile is a Primefaces model used to hold the image during
	 * uploading temporarily until comments are entered for the image
	 * It is not to be used for permanently accessing the image file.
	 */
	@Transient
	private UploadedFile uploadedFile;
	/**
	 * The DefaultStreamContent is a primefaces object used for streaming back
	 * the image uploaded so that comments can be entered for the image
	 */
	@Transient
	private DefaultStreamedContent content;
	
	@Column(name = "COMMENT_COUNT", nullable = false)
	private int commentCount;
	
	@Column(name = "VOTE_COUNT", nullable = false)
	private int voteCount;

	@Column(name = "TAG_COUNT", nullable = false)
	private int tagCount;
	
	@Column(name = "VIEW_COUNT", nullable = false)
	private int viewCount;

	public Image() {
	}

	public Image(int imageId, Event event, EventSecurityUser eventSecurityUser,
			String fileId, String fileName, String filePath,
			Date uploadDateTime, int fileSize, short imageWidth,
			short imageHeight, short fileTypeId, String eventDescription,
			short imageStatusTypeId, Timestamp createTimestamp, long createdBy) {
		this.imageId = imageId;
		this.event = event;
		this.eventSecurityUser = eventSecurityUser;
		this.fileId = fileId;
		this.fileName = fileName;
		this.filePath = filePath;
		this.uploadDateTime = uploadDateTime;
		this.fileSize = fileSize;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
		this.fileTypeId = fileTypeId;
		this.eventDescription = eventDescription;
		this.imageStatusTypeId = imageStatusTypeId;
		this.createTimestamp = createTimestamp;
		this.createdBy = createdBy;
	}

	public Image(int imageId, Event event, EventSecurityUser eventSecurityUser,
			String fileId, String fileName, String filePath,
			Date uploadDateTime, int fileSize, short imageWidth,
			short imageHeight, short fileTypeId, String eventDescription,
			Short imageSourceId, short imageStatusTypeId, Timestamp createTimestamp,
			long createdBy, Timestamp updateTimestamp, Long updatedBy,
			List<ImageTag> imageTags, Set<ImageVote> imageVotes,
			Set<Comment> comments) {
		this.imageId = imageId;
		this.event = event;
		this.eventSecurityUser = eventSecurityUser;
		this.fileId = fileId;
		this.fileName = fileName;
		this.filePath = filePath;
		this.uploadDateTime = uploadDateTime;
		this.fileSize = fileSize;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
		this.fileTypeId = fileTypeId;
		this.eventDescription = eventDescription;
		this.imageSourceId = imageSourceId;
		this.imageStatusTypeId = imageStatusTypeId;
		this.createTimestamp = createTimestamp;
		this.createdBy = createdBy;
		this.updateTimestamp = updateTimestamp;
		this.updatedBy = updatedBy;
		this.imageTags = imageTags;
		this.imageVotes = imageVotes;
		this.comments = comments;
	}

	@XmlElement
	public long getImageId() {
		return this.imageId;
	}

	public void setImageId(long imageId) {
		this.imageId = imageId;
	}

	@XmlTransient
	public Event getEvent() {
		return this.event;
	}

	public void setEvent(Event event) {
		this.event = event;
	}

	@XmlTransient
	public EventSecurityUser getEventSecurityUser() {
		return this.eventSecurityUser;
	}

	public void setEventSecurityUser(EventSecurityUser eventSecurityUser) {
		this.eventSecurityUser = eventSecurityUser;
	}

	@XmlElement
	public String getFileId() {
		return this.fileId;
	}

	public void setFileId(String fileId) {
		this.fileId = fileId;
	}

	@XmlElement
	public String getFileName() {
		return this.fileName;
	}

	public void setFileName(String fileName) {
		this.fileName = fileName;
	}

	@XmlElement
	public String getFilePath() {
		return this.filePath;
	}

	public void setFilePath(String filePath) {
		this.filePath = filePath;
	}

	@XmlElement
	public Date getUploadDateTime() {
		return this.uploadDateTime;
	}

	public void setUploadDateTime(Date uploadDateTime) {
		this.uploadDateTime = uploadDateTime;
	}

	@XmlElement
	public long getFileSize() {
		return this.fileSize;
	}

	public void setFileSize(long l) {
		this.fileSize = l;
	}

	@XmlElement
	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	@XmlElement
	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	@XmlElement
	public Short getFileTypeId() {
		return this.fileTypeId;
	}

	public void setFileTypeId(Short fileTypeId) {
		this.fileTypeId = fileTypeId;
	}

	@XmlElement
	public String getEventDescription() {
		return this.eventDescription;
	}

	public void setEventDescription(String eventDescription) {
		this.eventDescription = eventDescription;
	}

	@XmlElement
	public Short getImageSourceId() {
		return this.imageSourceId;
	}

	public void setImageSourceId(Short imageSourceId) {
		this.imageSourceId = imageSourceId;
	}

	@XmlElement
	public short getImageStatusTypeId() {
		return this.imageStatusTypeId;
	}

	public void setImageStatusTypeId(short imageStatusTypeId) {
		this.imageStatusTypeId = imageStatusTypeId;
	}


	public String getOriginalFileName() {
		return originalFileName;
	}

	public void setOriginalFileName(String originalFileName) {
		this.originalFileName = originalFileName;
	}

	@XmlTransient
	public List<ImageTag> getImageTags() {
		return this.imageTags;
	}

	public void setImageTags(List<ImageTag> imageTags) {
		this.imageTags = imageTags;
	}

	@XmlTransient
	public Set<ImageVote> getImageVotes() {
		return this.imageVotes;
	}

	public void setImageVotes(Set<ImageVote> imageVotes) {
		this.imageVotes = imageVotes;
	}

	@XmlTransient
	public Set<Comment> getComments() {
		return this.comments;
	}

	public void setComments(Set<Comment> comments) {
		this.comments = comments;
	}

	public void setUploadedFile(UploadedFile file) {
		this.uploadedFile = file;		
	}
	
	@XmlTransient
	public UploadedFile getUploadedFile()
	{
		return this.uploadedFile;
	}
	

	@XmlTransient
	public StreamedContent getContent() throws IOException
    {
    	FacesContext context = FacesContext.getCurrentInstance();
    	if (context.getCurrentPhaseId() == PhaseId.RENDER_RESPONSE) {
             // So, we're rendering the HTML. Return a stub StreamedContent so that it will generate right URL.
             return new DefaultStreamedContent();
         }
    	
    	else
        {
            
            content = new DefaultStreamedContent(uploadedFile.getInputstream(), uploadedFile.getContentType(), uploadedFile.getFileName());
        
        }
        return content;
    }

    @XmlElement
	public int getCommentCount() {
		return commentCount;
	}

	public void setCommentCount(int commentCount) {
		this.commentCount = commentCount;
	}

	@XmlElement
	public int getVoteCount() {
		return voteCount;
	}

	public void setVoteCount(int voteCount) {
		this.voteCount = voteCount;
	}

	@XmlElement
	public int getTagCount() {
		return tagCount;
	}

	public void setTagCount(int tagCount) {
		this.tagCount = tagCount;
	}

	public int getViewCount() {
		return viewCount;
	}

	public void setViewCount(int viewCount) {
		this.viewCount = viewCount;
	}

	/**
	 * @return the imageViewCount
	 */
	public Set<ImageViewCount> getImageViewCount() {
		return imageViewCount;
	}

	/**
	 * @param imageViewCount the imageViewCount to set
	 */
	public void setImageViewCount(Set<ImageViewCount> imageViewCount) {
		this.imageViewCount = imageViewCount;
	}

}
